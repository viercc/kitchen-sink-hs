{-# LANGUAGE RankNTypes #-}
module EquivalenceUtil(uniqueUpTo, uniqueUpToH) where

import Data.Hashable (Hashable(..))
import Data.Containers.ListUtils (nubOrd)
import Data.Foldable (for_)
import Data.Equivalence.Monad

{-|
Given a list of functions @fs = [f, g, ...]@ and a list of values @as = [a1, a2, ...]@,
return a list of values among @(id : fs) <*> as :: [a]@.

The returned values are unique up to the equivalence relation @(âˆ¼)@ generated from relations
@a ~ f a@ for all combinations of @a@ and @f@ from @as, fs@ respectively.

These values are the minimum element (with regard to the @Ord a@ instnace) from each equivalence classes.

Special cases:

- If @as@ is closed under the actions of @fs@, in other words every function in @fs@ never maps
  any value in @as@ to another value not on the list, the returned list is a subset of values of @as@.

- If @as@ is closed under the actions of @fs@ and every function in @fs@ is invertible,
  the equivalence classes can be thought as orbits of @as@ under the action of the permutation
  group @G@ generated by functions @fs@.

-}
uniqueUpTo :: Ord a => [a -> a] -> [a] -> [a]
uniqueUpTo isoGenerators as = runEquivM id min $ do
  for_ as $ \a -> equateAll $ nubOrd (a : map ($ a) isoGenerators)
  classes >>= traverse desc

data Hashed a = Hashed !Int a
    deriving (Eq, Ord)

hashed :: Hashable a => a -> Hashed a
hashed a = Hashed (hash a) a

unhashed :: Hashed a -> a
unhashed (Hashed _ a) = a

{-|
Do the same thing to 'uniqueUpToH' except it uses an alternative ordering on
@a@, based on hash values of them.

If the comparison using @Ord a@ instance is computationally costly, this can be
more efficient.

The returned values will be different to what @uniqueUpTo@ computes,
but they are equivalent to each other.
-}
uniqueUpToH :: (Hashable a, Ord a) => [a -> a] -> [a] -> [a]
uniqueUpToH isoGenerators as = unhashed <$> uniqueUpTo isoGenerators' as'
  where
    as' = hashed <$> as
    isoGenerators' = (\f -> hashed . f . unhashed) <$> isoGenerators